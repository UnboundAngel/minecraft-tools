<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seed Explorer - Minecraft Tools</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #0a0e1a;
            --bg-panel: #141824;
            --bg-panel-alt: #1a1f2e;
            --accent: #4ade80;
            --accent-soft: #86efac;
            --accent-hover: #22c55e;
            --accent-warn: #fbbf24;
            --grid-line: #2a3142;
            --text-main: #f5f5f7;
            --text-muted: #9ca3af;
            --border-subtle: #2a3142;
            --shadow-soft: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-main);
            color: var(--text-main);
            overflow: hidden;
        }

        .warning-banner {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: #000;
            padding: 12px 20px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            border-bottom: 2px solid #b45309;
        }

        .container {
            display: flex;
            height: calc(100vh - 44px);
        }

        .sidebar {
            width: 320px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border-subtle);
            overflow-y: auto;
            padding: 20px;
        }

        .sidebar h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent);
        }

        .control-group {
            margin-bottom: 24px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .control-group:last-child {
            border-bottom: none;
        }

        .control-group h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-soft);
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        input, select {
            width: 100%;
            padding: 10px;
            background: var(--bg-panel-alt);
            border: 1px solid var(--border-subtle);
            border-radius: 6px;
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .btn {
            padding: 10px;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-panel-alt);
            border: 1px solid var(--border-subtle);
            color: var(--text-main);
        }

        .btn-secondary:hover {
            background: var(--border-subtle);
        }

        .checkbox-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input {
            width: auto;
            margin: 0;
        }

        .checkbox-item label {
            margin: 0;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-main);
        }

        .map-area {
            flex: 1;
            position: relative;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .map-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 24, 36, 0.95);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(10px);
        }

        .map-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 24, 36, 0.95);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .zoom-display {
            color: var(--accent);
            font-weight: 600;
        }

        .hotbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(20, 24, 36, 0.98);
            border-top: 2px solid var(--accent);
            padding: 8px;
            display: flex;
            justify-content: center;
            gap: 4px;
            z-index: 1000;
        }

        .hotbar-slot {
            width: 60px;
            height: 60px;
            background: var(--bg-panel-alt);
            border: 2px solid var(--border-subtle);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            color: var(--text-muted);
            transition: all 0.2s;
            font-size: 0.7rem;
        }

        .hotbar-slot:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .hotbar-slot.active {
            border-color: var(--accent);
            background: rgba(74, 222, 128, 0.1);
        }

        .hotbar-icon {
            font-size: 1.5rem;
            margin-bottom: 2px;
        }
    </style>
</head>
<body>
    <div class="warning-banner">
        ‚ö†Ô∏è APPROXIMATE PREVIEW - This uses simplified worldgen. Does not exactly match real Minecraft worlds. For accurate results, integrate with cubiomes or similar.
    </div>

    <div class="container">
        <div class="sidebar">
            <h2>üß≠ Seed Explorer</h2>

            <div class="control-group">
                <h3>Seed</h3>
                <label>World Seed</label>
                <input type="text" id="seedInput" placeholder="Enter seed">
                <div class="btn-group">
                    <button class="btn" id="randomBtn">Random</button>
                    <button class="btn" id="generateBtn">Generate</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Navigation</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <input type="number" id="jumpX" placeholder="X">
                    <input type="number" id="jumpZ" placeholder="Z">
                </div>
                <button class="btn btn-secondary" id="jumpBtn" style="width: 100%;">Jump to Coords</button>
            </div>

            <div class="control-group">
                <h3>Overlays</h3>
                <div class="checkbox-list">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showStructures" checked>
                        <label for="showStructures">Show Structures</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showSlime" checked>
                        <label for="showSlime">Show Slime Chunks</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showSpawn" checked>
                        <label for="showSpawn">Show Spawn Point</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showGrid">
                        <label for="showGrid">Show Chunk Grid</label>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>Info</h3>
                <p style="font-size: 0.85rem; color: var(--text-muted); line-height: 1.5;">
                    <strong>Controls:</strong><br>
                    ‚Ä¢ Drag to pan<br>
                    ‚Ä¢ Scroll to zoom<br>
                    ‚Ä¢ Click structures for info<br>
                    ‚Ä¢ Zoom range: 0.1x - 20x
                </p>
            </div>
        </div>

        <div class="map-area">
            <canvas id="canvas"></canvas>

            <div class="map-info">
                <div>Seed: <span id="displaySeed">-</span></div>
                <div>Position: <span id="displayPos">X: 0, Z: 0</span></div>
                <div>Zoom: <span class="zoom-display" id="displayZoom">1.0x</span></div>
            </div>
        </div>
    </div>

    <!-- Navigation Hotbar -->
    <div class="hotbar">
        <a href="index.html" class="hotbar-slot">
            <div class="hotbar-icon">üè†</div>
            HOME
        </a>
        <a href="enchantment_calculator.html" class="hotbar-slot">
            <div class="hotbar-icon">üìò</div>
            ENCHANT
        </a>
        <a href="ore_guide_page.html" class="hotbar-slot">
            <div class="hotbar-icon">üíé</div>
            ORES
        </a>
        <a href="world_seeds_page.html" class="hotbar-slot">
            <div class="hotbar-icon">üó∫Ô∏è</div>
            SEEDS
        </a>
        <a href="seed_explorer.html" class="hotbar-slot active">
            <div class="hotbar-icon">üß≠</div>
            EXPLORER
        </a>
        <a href="build_ideas_gallery.html" class="hotbar-slot">
            <div class="hotbar-icon">üóùÔ∏è</div>
            BUILDS
        </a>
        <a href="farm_efficiency_page.html" class="hotbar-slot">
            <div class="hotbar-icon">üåæ</div>
            FARMS
        </a>
        <a href="potion_brewing_guide.html" class="hotbar-slot">
            <div class="hotbar-icon">üß™</div>
            POTIONS
        </a>
    </div>

    <script>
        // ============================================================================
        // WORLDGEN ABSTRACTION LAYER
        // This is where a real Minecraft worldgen implementation should be plugged in
        // Replace SimplifiedWorldgen with cubiomes-based implementation for accuracy
        // ============================================================================

        class WorldgenInterface {
            /**
             * Initialize worldgen (load WASM, etc)
             */
            async init() {}

            /**
             * Get biome at block coordinates
             * @param {number} seed - World seed
             * @param {string} edition - "Java" or "Bedrock"
             * @param {string} version - e.g. "1.20"
             * @param {string} dimension - "overworld", "nether", or "end"
             * @param {number} blockX - Block X coordinate
             * @param {number} blockZ - Block Z coordinate
             * @returns {string} Biome ID
             */
            getBiomeAt(seed, edition, version, dimension, blockX, blockZ) {
                throw new Error("Must implement getBiomeAt");
            }

            /**
             * Get all structures in block coordinate area
             * @param {number} seed
             * @param {string} edition
             * @param {string} version
             * @param {string} dimension
             * @param {number} minBlockX
             * @param {number} minBlockZ
             * @param {number} maxBlockX
             * @param {number} maxBlockZ
             * @returns {Array} [{type: 'village', blockX, blockZ}, ...]
             */
            getStructuresInArea(seed, edition, version, dimension, minBlockX, minBlockZ, maxBlockX, maxBlockZ) {
                throw new Error("Must implement getStructuresInArea");
            }

            /**
             * Check if chunk is a slime chunk
             * @param {number} seed
             * @param {string} edition
             * @param {string} version
             * @param {number} chunkX - Chunk X (blockX >> 4)
             * @param {number} chunkZ - Chunk Z (blockZ >> 4)
             * @returns {boolean}
             */
            isSlimeChunk(seed, edition, version, chunkX, chunkZ) {
                throw new Error("Must implement isSlimeChunk");
            }
        }

        // ============================================================================
        // SIMPLIFIED WORLDGEN (TEMPORARY - NOT ACCURATE)
        // This is a placeholder using very basic noise
        // Does NOT match real Minecraft - clearly labeled as approximate
        // ============================================================================

        class SimplifiedWorldgen extends WorldgenInterface {
            constructor() {
                super();
                this.biomeColors = {
                    ocean: '#000070',
                    plains: '#8db360',
                    desert: '#fa9418',
                    forest: '#056621',
                    taiga: '#0b6659',
                    swamp: '#07f9b2',
                    river: '#0000ff',
                    snowy: '#ffffff',
                    mushroom: '#ff00ff',
                };
            }

            // Simple hash for deterministic randomness
            hash(seed, x, z) {
                let h = seed;
                h = (h * 374761393 + x) | 0;
                h = (h * 668265263 + z) | 0;
                h ^= h >>> 13;
                h = (h * 1274126177) | 0;
                h ^= h >>> 16;
                return h;
            }

            // Simple noise - NOT Minecraft's actual noise
            simpleNoise(seed, x, z, scale) {
                const ix = Math.floor(x / scale);
                const iz = Math.floor(z / scale);
                const h = this.hash(seed, ix, iz);
                return ((h >>> 0) / 4294967296) * 2 - 1;
            }

            getBiomeAt(seed, edition, version, dimension, blockX, blockZ) {
                // VERY simplified - just for visual variety
                // Real implementation would use Minecraft's actual noise generators
                const noise = this.simpleNoise(seed, blockX, blockZ, 256);

                if (noise < -0.5) return 'ocean';
                if (noise < -0.2) return 'river';
                if (noise < 0.1) return 'plains';
                if (noise < 0.3) return 'forest';
                if (noise < 0.5) return 'taiga';
                if (noise < 0.7) return 'desert';
                return 'plains';
            }

            getStructuresInArea(seed, edition, version, dimension, minBlockX, minBlockZ, maxBlockX, maxBlockZ) {
                // Simplified structure generation - NOT accurate to Minecraft
                // Real implementation would use Minecraft's region-based structure generation
                const structures = [];
                const structureSpacing = 512; // blocks

                const minRegionX = Math.floor(minBlockX / structureSpacing);
                const maxRegionX = Math.floor(maxBlockX / structureSpacing);
                const minRegionZ = Math.floor(minBlockZ / structureSpacing);
                const maxRegionZ = Math.floor(maxBlockZ / structureSpacing);

                for (let rx = minRegionX; rx <= maxRegionX; rx++) {
                    for (let rz = minRegionZ; rz <= maxRegionZ; rz++) {
                        const h = this.hash(seed, rx, rz);
                        const val = (h >>> 0) / 4294967296;

                        if (val < 0.3) {
                            const blockX = rx * structureSpacing + ((h >>> 8) & 0xFF) * 2;
                            const blockZ = rz * structureSpacing + ((h >>> 16) & 0xFF) * 2;

                            if (blockX >= minBlockX && blockX <= maxBlockX &&
                                blockZ >= minBlockZ && blockZ <= maxBlockZ) {
                                structures.push({
                                    type: 'village',
                                    blockX,
                                    blockZ
                                });
                            }
                        }
                    }
                }

                return structures;
            }

            // Real slime chunk algorithm from Minecraft Java Edition
            isSlimeChunk(seed, edition, version, chunkX, chunkZ) {
                if (edition !== 'Java') return false; // Bedrock uses different system

                // This is the actual Minecraft Java slime chunk algorithm
                const n = chunkX * 0x1f1f1f1f ^ chunkZ;
                const seedPart = ((seed & 0xffffffffn) + BigInt(n)) & 0xffffffffn;

                // Java Random initialization
                let random = (seedPart ^ 0x5deece66dn) & ((1n << 48n) - 1n);

                // nextInt(10) == 0
                random = (random * 0x5deece66dn + 0xbn) & ((1n << 48n) - 1n);
                const result = Number((random >> 17n) % 10n);

                return result === 0;
            }
        }

        // ============================================================================
        // COORDINATE SYSTEM UTILITIES
        // Clear separation between blocks, chunks, and screen pixels
        // ============================================================================

        const Coords = {
            // Block -> Chunk
            blockToChunk(blockCoord) {
                return Math.floor(blockCoord / 16);
            },

            // Chunk -> Block (center of chunk)
            chunkToBlock(chunkCoord) {
                return chunkCoord * 16 + 8;
            },

            // World block -> Screen pixel
            blockToScreen(blockX, blockZ, camera, canvasWidth, canvasHeight) {
                const screenX = (blockX - camera.blockX) * camera.pixelsPerBlock + canvasWidth / 2;
                const screenY = (blockZ - camera.blockZ) * camera.pixelsPerBlock + canvasHeight / 2;
                return {x: screenX, y: screenY};
            },

            // Screen pixel -> World block
            screenToBlock(screenX, screenY, camera, canvasWidth, canvasHeight) {
                const blockX = (screenX - canvasWidth / 2) / camera.pixelsPerBlock + camera.blockX;
                const blockZ = (screenY - canvasHeight / 2) / camera.pixelsPerBlock + camera.blockZ;
                return {blockX, blockZ};
            }
        };

        // ============================================================================
        // RENDERER
        // Handles all canvas drawing - does NOT know about worldgen internals
        // ============================================================================

        class Renderer {
            constructor(canvas, worldgen) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.worldgen = worldgen;

                // Camera state (in block coordinates)
                this.camera = {
                    blockX: 0,
                    blockZ: 0,
                    zoom: 1.0, // 1.0 = 1 pixel per block
                    pixelsPerBlock: 1.0
                };

                this.seed = 0;
                this.edition = 'Java';
                this.version = '1.20';
                this.dimension = 'overworld';

                // Overlays
                this.showStructures = true;
                this.showSlime = true;
                this.showSpawn = true;
                this.showGrid = false;

                this.resizeCanvas();
            }

            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.canvas.clientWidth * dpr;
                this.canvas.height = this.canvas.clientHeight * dpr;
                this.ctx.scale(dpr, dpr);
            }

            setCamera(blockX, blockZ, zoom) {
                this.camera.blockX = blockX;
                this.camera.blockZ = blockZ;
                this.camera.zoom = Math.max(0.1, Math.min(20, zoom));
                this.camera.pixelsPerBlock = this.camera.zoom;
            }

            render() {
                const w = this.canvas.clientWidth;
                const h = this.canvas.clientHeight;
                const ctx = this.ctx;

                // Clear
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);

                // Calculate visible block area
                const topLeft = Coords.screenToBlock(0, 0, this.camera, w, h);
                const bottomRight = Coords.screenToBlock(w, h, this.camera, w, h);

                // Sample biomes on a grid
                const sampleSpacing = Math.max(1, Math.floor(16 / this.camera.pixelsPerBlock));

                for (let blockZ = Math.floor(topLeft.blockZ / sampleSpacing) * sampleSpacing;
                     blockZ <= bottomRight.blockZ;
                     blockZ += sampleSpacing) {
                    for (let blockX = Math.floor(topLeft.blockX / sampleSpacing) * sampleSpacing;
                         blockX <= bottomRight.blockX;
                         blockX += sampleSpacing) {

                        const biome = this.worldgen.getBiomeAt(
                            this.seed, this.edition, this.version, this.dimension,
                            blockX, blockZ
                        );

                        const color = this.worldgen.biomeColors[biome] || '#333';
                        const screen = Coords.blockToScreen(blockX, blockZ, this.camera, w, h);
                        const size = sampleSpacing * this.camera.pixelsPerBlock;

                        ctx.fillStyle = color;
                        ctx.fillRect(screen.x, screen.y, size, size);
                    }
                }

                // Draw chunk grid
                if (this.showGrid && this.camera.zoom >= 0.5) {
                    this.drawChunkGrid(topLeft, bottomRight, w, h);
                }

                // Draw slime chunks
                if (this.showSlime) {
                    this.drawSlimeChunks(topLeft, bottomRight, w, h);
                }

                // Draw spawn
                if (this.showSpawn) {
                    this.drawSpawn(w, h);
                }

                // Draw structures
                if (this.showStructures) {
                    this.drawStructures(topLeft, bottomRight, w, h);
                }
            }

            drawChunkGrid(topLeft, bottomRight, w, h) {
                const ctx = this.ctx;
                const minChunkX = Coords.blockToChunk(Math.floor(topLeft.blockX));
                const maxChunkX = Coords.blockToChunk(Math.ceil(bottomRight.blockX));
                const minChunkZ = Coords.blockToChunk(Math.floor(topLeft.blockZ));
                const maxChunkZ = Coords.blockToChunk(Math.ceil(bottomRight.blockZ));

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;

                for (let cx = minChunkX; cx <= maxChunkX; cx++) {
                    const blockX = cx * 16;
                    const screen = Coords.blockToScreen(blockX, 0, this.camera, w, h);
                    ctx.beginPath();
                    ctx.moveTo(screen.x, 0);
                    ctx.lineTo(screen.x, h);
                    ctx.stroke();
                }

                for (let cz = minChunkZ; cz <= maxChunkZ; cz++) {
                    const blockZ = cz * 16;
                    const screen = Coords.blockToScreen(0, blockZ, this.camera, w, h);
                    ctx.beginPath();
                    ctx.moveTo(0, screen.y);
                    ctx.lineTo(w, screen.y);
                    ctx.stroke();
                }
            }

            drawSlimeChunks(topLeft, bottomRight, w, h) {
                const ctx = this.ctx;
                const minChunkX = Coords.blockToChunk(Math.floor(topLeft.blockX));
                const maxChunkX = Coords.blockToChunk(Math.ceil(bottomRight.blockX));
                const minChunkZ = Coords.blockToChunk(Math.floor(topLeft.blockZ));
                const maxChunkZ = Coords.blockToChunk(Math.ceil(bottomRight.blockZ));

                ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';

                for (let cx = minChunkX; cx <= maxChunkX; cx++) {
                    for (let cz = minChunkZ; cz <= maxChunkZ; cz++) {
                        if (this.worldgen.isSlimeChunk(this.seed, this.edition, this.version, cx, cz)) {
                            const blockX = cx * 16;
                            const blockZ = cz * 16;
                            const screen = Coords.blockToScreen(blockX, blockZ, this.camera, w, h);
                            const size = 16 * this.camera.pixelsPerBlock;
                            ctx.fillRect(screen.x, screen.y, size, size);
                        }
                    }
                }
            }

            drawSpawn(w, h) {
                const screen = Coords.blockToScreen(0, 0, this.camera, w, h);
                const ctx = this.ctx;

                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.arc(screen.x, screen.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Crosshair
                ctx.beginPath();
                ctx.moveTo(screen.x - 12, screen.y);
                ctx.lineTo(screen.x + 12, screen.y);
                ctx.moveTo(screen.x, screen.y - 12);
                ctx.lineTo(screen.x, screen.y + 12);
                ctx.stroke();
            }

            drawStructures(topLeft, bottomRight, w, h) {
                const structures = this.worldgen.getStructuresInArea(
                    this.seed, this.edition, this.version, this.dimension,
                    Math.floor(topLeft.blockX),
                    Math.floor(topLeft.blockZ),
                    Math.ceil(bottomRight.blockX),
                    Math.ceil(bottomRight.blockZ)
                );

                const ctx = this.ctx;
                ctx.fillStyle = '#ff0000';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;

                structures.forEach(s => {
                    const screen = Coords.blockToScreen(s.blockX, s.blockZ, this.camera, w, h);

                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    if (this.camera.zoom >= 2) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '12px Inter';
                        ctx.textAlign = 'center';
                        ctx.fillText(s.type, screen.x, screen.y - 10);
                        ctx.fillStyle = '#ff0000';
                    }
                });
            }
        }

        // ============================================================================
        // APP CONTROLLER
        // ============================================================================

        class App {
            constructor() {
                this.worldgen = new SimplifiedWorldgen();
                this.renderer = new Renderer(document.getElementById('canvas'), this.worldgen);

                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;

                this.setupEvents();
                this.generate();
            }

            generate() {
                const seedInput = document.getElementById('seedInput').value;
                this.renderer.seed = seedInput ? this.hashSeed(seedInput) : Math.floor(Math.random() * 1000000000);

                document.getElementById('displaySeed').textContent = seedInput || this.renderer.seed;

                this.renderer.render();
            }

            hashSeed(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash = hash & hash;
                }
                return hash;
            }

            setupEvents() {
                const canvas = this.renderer.canvas;

                // Random seed
                document.getElementById('randomBtn').onclick = () => {
                    document.getElementById('seedInput').value = Math.floor(Math.random() * 1000000000);
                };

                // Generate
                document.getElementById('generateBtn').onclick = () => this.generate();

                // Jump
                document.getElementById('jumpBtn').onclick = () => {
                    const x = parseInt(document.getElementById('jumpX').value) || 0;
                    const z = parseInt(document.getElementById('jumpZ').value) || 0;
                    this.renderer.setCamera(x, z, this.renderer.camera.zoom);
                    this.renderer.render();
                    this.updateInfo();
                };

                // Overlays
                document.getElementById('showStructures').onchange = (e) => {
                    this.renderer.showStructures = e.target.checked;
                    this.renderer.render();
                };
                document.getElementById('showSlime').onchange = (e) => {
                    this.renderer.showSlime = e.target.checked;
                    this.renderer.render();
                };
                document.getElementById('showSpawn').onchange = (e) => {
                    this.renderer.showSpawn = e.target.checked;
                    this.renderer.render();
                };
                document.getElementById('showGrid').onchange = (e) => {
                    this.renderer.showGrid = e.target.checked;
                    this.renderer.render();
                };

                // Mouse pan
                canvas.onmousedown = (e) => {
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                };

                canvas.onmousemove = (e) => {
                    if (this.isDragging) {
                        const dx = e.clientX - this.lastMouseX;
                        const dy = e.clientY - this.lastMouseY;

                        const cam = this.renderer.camera;
                        cam.blockX -= dx / cam.pixelsPerBlock;
                        cam.blockZ -= dy / cam.pixelsPerBlock;

                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;

                        this.renderer.render();
                        this.updateInfo();
                    }
                };

                canvas.onmouseup = () => {
                    this.isDragging = false;
                };

                canvas.onmouseleave = () => {
                    this.isDragging = false;
                };

                // Mouse zoom
                canvas.onwheel = (e) => {
                    e.preventDefault();

                    const zoomFactor = e.deltaY < 0 ? 1.2 : 0.8;
                    const newZoom = this.renderer.camera.zoom * zoomFactor;

                    this.renderer.setCamera(
                        this.renderer.camera.blockX,
                        this.renderer.camera.blockZ,
                        newZoom
                    );

                    this.renderer.render();
                    this.updateInfo();
                };

                // Resize
                window.onresize = () => {
                    this.renderer.resizeCanvas();
                    this.renderer.render();
                };
            }

            updateInfo() {
                const cam = this.renderer.camera;
                document.getElementById('displayPos').textContent =
                    `X: ${Math.round(cam.blockX)}, Z: ${Math.round(cam.blockZ)}`;
                document.getElementById('displayZoom').textContent =
                    cam.zoom.toFixed(2) + 'x';
            }
        }

        // Start app
        const app = new App();
    </script>
</body>
</html>
